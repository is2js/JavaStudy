package day06;

public class 인터페이스 {
	
	//1. 인터페이스:  추상클래스보다 추상화의 정도가 높아서 몸통을 갖춘 일반 메서드 또는 멤버변수를 구성원으로 가질 수 없고 -> ***추상메서드와 [[[상수]]]만을 멤버****
	// 추상클래스가 미완성 설계도라면, 인터페이스는 밑그림만 그려져 있는 기본 설계도
//	 interface 인터페이스이름 {
//	        public static final 타입 상수이름 = 값;
//	        public abstract 메서드이름(매개변수목록);
//	    }
	
	//[[[인터페이스의 멤버들은 제약사항]]]]이 있다.
	// 1. 모든 ****멤버변수는 public static final****이어야 하며, ****이를 생략할 수 있다.****
	// 2. 모든 ****메서드는 public abstract****이어야 하며, 이를 ****생략할 수 있다.**** 단, static 메서드와 default 메서드는 예외(JDK 1.8부터)
	// -> 생략된 제어자는 컴파일러가 자동적으로 추가해준다.
	
	//2. 구현: 인터페이스도 추상클래스처럼 그 자체로는 인스턴스를 생성할 수 없다. 키워드 ‘extends’가 아닌 구현한다는 의미의 ‘implements’를 사용한다.
	// -> 만일 구현하는 인터페이스의 메서드 중 일부만 구현한다면, **구현안한 나머지는 abstract을 붙여서 추상클래스로 선언해야 한다.**
	//또한 상속과 구현을 동시에 할 수도 있다.
	
	//3. 인터페이스 사용 by ****인터페이스 참조 변수를 다형성 부모 참조변수로****
	// I) 챔피언
	
	// M)LaneCheck.getLane() -> I) 챔피온 반환 -> **실제I)챔피언 객체를 반환하는게 아니라 I)를 구현한 자식Class의 객체를 다형성으로 받아서 반환함.**
	// -> 내부에서 인터페이스 구현 클래스를 생성하고 반환할 것이다.
	
	// C1) marksman implements I)챔피온
	// C2) Nuker implements I)챔피온
	// C3) Jungle implements I)챔피온
	
	// -> **카테고리를 I)로 공통기능을 I-추상메서드)로 정의해놓고, **
	// --> 하위 자식들을 C1,2,3) implements I)챔피온 하면서 추상메서드도 **공통기능이지만, 구현은 각각 자신의 특성에 맞게 구현**한다.
	// ---> 유틸용 클래스.static메서드를 I)객체를 반환하게 한다.? ----인터페이스의 객체는 없다 대신 참조변수에 --> I)챔피언을 구현한 C1,C2,C3)의 객체를 생성해서 반화한다.
	// 실습.
	
	// 4. 인터페이스 변화
	// 4-1. Default Method
//	   인터페이스에 메서드를 추가한다는 것은, 추상 메서드를 추가한다는 것이고, 이 인터페이스를 구현한 기존의 모든 클래스들이 새로 추가된 메서드를 구현해야 한다.
//	   인터페이스가 변경되지 않으면 제일 좋지만, 언젠가는 변경이 발생하기 마련이다. 이를 해결하기 위해서 디폴트 메서드(default method)라는 것이 고안되었다. 
//	   디폴트 메서드는 추상 메서드의 기본적인 구현을 제공하는 메서드로, 추상 메서드가 아니기 때문에 디폴트 메서드가 새롭게 추가되어도 해당 인터페이스를 구현한 클래스를 변경하지 않아도 된다.
	//   디폴트 메서드는 앞에 키워드 default를 붙이며, **추상 메서드와 달리 일반 메서드처럼 몸통 { }이 있어야 한다. 접근 제어자는 public이며, 생략이 가능하다.**
//    interface MyInterface {
//        void method();
//        // void newMethod();  추상 메서드
//        default void newMethod() { }
//    }
//	추상 메서드를 추가하는 대신 디폴트 메서드를 추가하면 조상 클래스에 새로운 메서드를 추가한 것과 동일한 효과를 얻는다.
//	디폴트 메서드 충돌 규칙
//	새로 추가된 디폴트 메서드가 기존의 메서드와 이름이 중복되어 충돌하는 경우 해결하는 규칙은 다음과 같다.
//	여러 인터페이스의 디폴트 메서드 간의 충돌: 	인터페이스를 구현한 클래스에서 디폴트 메서드를 오버라이딩해야 한다.
//	디폴트 메서드와 조상 클래스의 메서드 간의 충돌: 조상 클래스의 메서드가 상속되고, 디폴트 메서드는 무시된다.
//	단순하게 필요한 쪽의 메서드와 같은 내용으로 오버라이딩 해서 해결하는 방법도 있다.
//인터페이스의 static 메서드, 자바 8

	//	   Java 8부터 인터페이스에 static 메서드 추가가 가능해졌다. 클래스에서 작성하는 방법과 동일하게 작성할 수 있고, 접근 제어자는 항상 public이며 역시 생략이 가능하다.
//	   static 메서드는 오버라이딩이 불가능하다.
//	   인터페이스의 private 메서드, 자바 9
//	      Java 9부터 사용할 수 있게된 private 메서드는 다음과 같은 특성을 가지고 있다.
//	   메서드의 몸통 { }이 있고 abstract이 아니다.
//	   구현체에서 구현할 수 없고 자식 인터페이스에서 상속이 불가능하다.
//	   static 메서드도 private이 가능하다.
//	   private 메서드는 private, abstract, default 또는 static 메서드를 호출할 수 있다. private static은 static 및 static private 메서드만 호출 할 수 있다.






	

}
