package day06;

public class 패키지 {
	
	//1. 패키지 키워드 : 서관 클래스 or 인터페이스의 묶음
	// -> 서다 패키지면 클래스 이름 같아도됨. ->  클래스의 실제 이름(full name)은 패키지명을 포함 
	//     ex>  String 클래스의 패키지명을 포함한 이름은 java.lang.String
	// ->  클래스가 물리적으로 하나의 클래스파일(.class)인 것과 같이 패키지는 물리적으로 하나의 디렉토리
	//    클래스 -> .class파일과 1:1매칭     패키지 -> 물리적 디렉토리와 1:1매칭
	// -> (.)을 기준으로 패키지 속 하위 패키지 
	
//	하나의 소스파일에는 첫 번째 문장으로 단 **한 번의 패키지 선언**만을 허용한다.
//	모든 클래스는 반드시 하나의 패키지에 속해야 한다.
//	패키지는 점(.)을 구분자로 하여 계층구조로 구성할 수 있다. (디렉토리.서브디렉토리. 1:1매칭됨)
//	패키지는 물리적으로 클래스 파일(.class)을 포함하는 하나의 디렉토리이다.
	
	//모든 패키지는 반드시 하나의 패키지에 포함되어야 하는데, 패키지가 존재하지 않다면
	// -> 자바에서 기본으로 제공하는 이름없는 패키지(unnamed package or default package)가 패키지가 된다.
	// --> 그럼 PackageTest에서 이름없는 패키지에 있는 UnnamedPackage 클래스를 사용할 수 있을까? (X)
	// ---> my) 패키지 이름 없는 곳의 class는 다른데서 갖다 못쓴다...  cf) gradle: src>main> java>    이후로 패키지명 나옴
	// --> 이름없는 패키지에서는 같은 default package의 파일과 com.jihan.javastudycode.week7 패키지의 파일 모두 사용 (O)


	// 주석과 공백을 제외한 첫 번째 문장에 패키지 선언
//	패키지는 [[[주석과 공백을 제외]]]한 첫 번째 문장이어야 한다.
//	하나의 소스파일에 단 한번만 선언될 수 있다.
//	패키지명은 대소문자 모두 허용되지만, 클래스명과 구분을 위해 [[[소문자]]]로 해야한다.
//	패키지명과 위치한 [[[폴더의 이름이 같아야 한다.]]]
//	패키지명을 java로 시작하면 안된다. -> my) gradle에서는  main > java > src >  ... 이어지니까? 
	
	//2. import 키워드
//	하나의 패키지에 속한 여러 클래스를 사용할 경우 클래스 이름을 일일히 지정하기 보다는 [[패키지명.*과 같이 하는 것이 편리]]하다.
//	한 가지 주의해야 할 점은 import문에서 클래스의 이름 대신 [[[‘*‘을 사용하는 것이 하위 패키지의 클래스까지 포함하는 것은 아니다.]]]
//	  import java.util.*;
//    import java.text.*;
//
//	위의 두 문장을 아래와 같이 할 수 [[ 없다.]]]
//	    import java.*;
	
	// 내장패키지
	// java - lang - System, String, ...
	// java - util - ArrayList, Map
	// java -awt - Button
	
	//3. java.lang 패키지: 가장 기본이 되는 클래스들을 포함하고 있는 패키지
	// -> 다른 패키지들과 달리 모든 소스파일에 묵시적으로 선언 ->  System과 String 같은 java.lang 패키지에 속한 클래스들은 import문 없이 사용할 수 있었던 것
	
	//3-1. static import문: 특정클래스의 [객체 노상관 유틸용 클래스.static메소드]만 사용하고자할때 -> 특정 클래스의 static 멤버를 자주 호출 할 경우 편리하며, 코드도 간결해진다.
//    import static java.lang.Integer.*;    // Integer클래스의 모든 static메서드    
//    import static java.lang.Math.random;  // Math.random()만.    
//    import static java.lang.System.out;   // System.out을 out만으로 참조가능.
//    out.println(random());   //System.out.println(Math.random());
	
	
	//4. 클래스패스: 클래스를 찾기위한 경로이다. 즉, JVM이 프로그램을 실행할 때, 클래스 파일(.class)을 찾는데 기준이 되는 파일 경로
	// - 컴파일러가 만든 .class + 외부라이브러리 속 .class 들이 있는 경로 ---> JVM실행시 필요함.

	//4-1. classpath에 사용할 수 있는 값:    classpath는 콜론 ‘:’으로 구분된 디렉토리 및 파일 목록
	//-> 💡 리눅스, Mac 은 콜론(:)이며, 윈도우는 세미콜론(;)이다.
//	1. /dev/workspace/username/java/classes와 같은 ******디렉토리******
//	2. myclass.zip와 같은 ******zip******
//	3. myclass.jar와 같은 ******jar******(자바 아카이브)파일
	
	//4-2. CLASSPATH 환경변수: JVM의 클래스 로더는 CLASSPATH 환경변수를 호출해서 환경 변수에 설정되어 있는 디렉토리가 호출되면 그 디렉토리에 있는 클래스들을 먼저 JVM에 로드
	// - Mac에서는 터미널을 이용해서 설정하는데 환경변수 설정을 통해서 작성하는 윈도우와 달리 파일을 생성해주어야 했다.
//	ls -al을 사용하여 빨간 상자로 표시된 .bash_profile이 있는지 확인하고 없다면 만들면 된다.
//	vi 명령어를 통해서 파일을 수정 또는 생성하는데, 파일 내부에 다음과 같은 문장을 추가하면 PATH설정이 된다.
//	    export PATH=${PATH}
//	예를 들어 JDK 1.8을 기본으로 설정하고 PATH 설정을 하려면 다음과 같이 작성한 후 저장하면 된다.
//	    export PATH=${PATH}:$JAVA_HOME/bin
	
	//4-3. path가 없는데 어떻게 실행이 된걸까? 인텔리제이의 경우 인텔리제이 툴 내에서 JDK 설정을 따로 하기때문에 딱히 필요가 없었던거 같다
	
	//4-4. -classpath 옵션:    자바 프로그램을 실행시켜 주는 명령어가 제공되는데, 사용법은 다음과 같다.
	//     java <option> <classfile> <argument>
//	option : 옵션
//	classfile : 호출될 클래스 파일 이름
//	argument : ***main 함수에 파라미터로 보내질 문자열***
	
	//4-5.  -classpath 옵션 (-cp): 참조할 클래스 파일의 패스(경로)를 지정하는데, jar 파일, zip 파일, 클래스 파일의 디렉토리 위치를 적어주면 된다.
	//세 가지 유형을 모두 적용하면 classpath는 다음과 같게 된다.
	// /home/user/java/classes:/home/user/java/classes/myclasses.zip:/home/user/java/classes/myclasses.jar
	
	// 4-6 . CLASSPATH 환경변수
//	- windows시스템:   설정 > 환경변수리눅스, 
//	- 유닉스 계열이 시스템: /etc/profile 에 추가
//	그러나 이 방법은 추천되지 않는다. ****모든 프로젝트에서 이 환경변수를 바라볼 것이다. 좋지않다!****
//	대신, ****IDE나 빌드도구를 통해 클래스패스를 프로젝트 별로 설정할 수 있다. 보통 IDE가 자동으로 설정해준다.****
	// 인텔리제이의 경우 File -> Project Structure -> Project Settings -> Modules 탭 확인
	
	



	//5. 접근지시자: 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할
	// -> 클래스, 멤버변수, 생성자, 메서드   순서대로 4개 다 올 수 있음.
//	private : 같은 클래스 내에서만 접근이 가능하다. ->  외부에선 다른 public으로 접근하세요~~  같은 클래스 내에선 됩니다~~  
//	default : 같은 패키지 내에서만 접근이 가능하다.  -> default는 같은 패키지(디렉토리)내에선 됩니다~ 
//	protected : 같은 패키지 내에서, 그리고 다른 패키지의 자손 클래스에서 접근이 가능하다. -> 자식만 외부에서 가능
//	public : 접근 제한이 없다. -> 다른데서 갖다 쓸놈들은 다 달아주세요~~
	
	//****접근제어자 붙일 수 있는 4가지 입장에서보기****
	//1. class : 다른데서 쓸 클래스는 .java와 1:1매칭되도면서 & public다세요. **그외는 없습니다(default)**
	//2. 변수,메서드 : public(다갖쓰), protected(다 자식 가능), defaut, private(클래스내에서만쓰세요. 다른데선 public 메소드로 private변수에 접근하세요)
	//3. 지역변수: 불가
	
	// 5-1. 접근 제어자를 이용한 캡슐화 -> 주로 멤버에 접근 제어자를 사용하는 이유는 클래스 내부에 선언된 데이터를 보호
	// -> 접근시 get으로만 값만 받기(할당ㄴㄴㄴ) -> 입력시 set으로 같이 온 파라미터(인자)를 검사하고 넣기 등(할당시 검사후 할당)
	// ->-> 데이터 감추기(data hiding)라고 하며, 객체지향개념의 캡슐화(encapsulation)
	// ->  또다른 이유는 클래스 내에서만 사용되는, ***내부 작업용 임시 멤버변수*** 혹은 ***부분작업처리 용 메서드***들을 내부에 감추기ㄴ
	// ->-> 접근 제어자를 사용하는 이유
//	1.외부로부터 데이터를 보호하기 위해
//  2.외부에는 불필요한, 내부적으로만 사용되는 부분을 감추기 위해
	
	// getter는 IDE 툴에서 기본적으로 다 제공을 한다(인텔리제이, 이클립스). 이것도 귀찮으면 lombok을 사용하자.
	//-> setName() 과 같은 세터(setter) 메소드를 작성한다.
	//-> p.name 으로 하면되지 왜 setter가 필요할까? 라고 생각할 수도 있는데
//			아무나 이름을 다 바꿔줘서는 안된다. 개명한 사람일 경우에만 이름을 바꿔줘야하는 요구사항이 들어왔을 경우,
//			setName()에서 이 사람이 개명을 한 사용자 인지 체크 후 이름을 변경
	// -> **setter는 들어온 파라미터 검사 + [[[호출된 객체의 변경가능 검사]]]후 변경을 결정할 수 있게 된다.**
	
	
	// 6. 생성자의 접근제어자.
	// -> 생성자가 public이 아니면, 외부에서 객체를 생성할 수가 없다 -> 
	// **객체를 class내에서 private 참조변수(외부 [[[밖에선 직접]]] 사용X) + static(public이면유틸처럼 편하게사용 or private이면메모리1순위 생성)로 먼저 생성해놓고**
	// --> my) **private은 외부에서 ****직접****사용이 안되는 것.. 간접적으로 public 메소드 통해서는 가능.
	// --> my) **static은 public static-> (메모리1순위생성)유틸처럼 편하게 사용** / private static -> (메모리1순위생성) but [밖에선 간접적으로] 유틸처럼 사용
	// ---> my) **private 외부 직접X 간접으로라고 해석하기 + @같은 class내에선 직접가능@ for 싱글톤**
	// ---> my) **static 메모리1순위이며, 객체없이, 편하게 유틸처럼**
	// ----> ****private static - 외부직접X 간접으로만 & 객체없이 편하게 유틸처럼 사용****
	
	// **1) <생성자>에 private을 걸어, [외부 직접] <생성> [X], [간접] <생성> 만 가능하게 한다. + @같은 class내에선만 [직접] 생성가능하다.@
	// **->private 생성자, 1) 메소드통해 외부에서 간접생성하거나 or 2) class내에서 직접 생성  2가지만 가능하다.**
	// **2) <객체를 class내부에서 직접 생성핟나 private 생성자으로 인해 유일 생상가능한 곳이라서.> -> class호출시마다 객체 생성되면 어떻하게?  private static으로 객체 생성한면, <외부직접접근X 간접메소드로만접근 + 객체없이 편하게 유틸처럼, 메모리 1순위 
	// **3) public static [해당class타입] 메소드getInstance() : 외부에서 갖다쓰는, 노객체 유틸처럼 메소드를 가지고, 2)에서 유일 생성된 객체1개를 반환해서 쓰도록 한다.
//	디폴트 생성자에 private 키워드를 사용하여 인스턴스 생성을 막는다.
//	getInstance() 메소드에서 new Singleton()으로 만든 객체를 리턴한다.
//	이때, static 키워드가 붙은 이유는 인스턴스 생성을 하지 않고 호출하기 위함이다.
//	생성자가 private인 클래스는 다른 클래스의 조상이 될 수 없다. 왜냐하면, 자손클래스의 인스턴스를 생성할때,
//	조상클래스의 생성자를 호출하는 것이 불가능하기 때문이다.
//	그래서 클래스 앞에 final을 추가하여 상속할 수 없는 클래스라는 것을 알리는 것이 좋다.
	
	
	





	

}
