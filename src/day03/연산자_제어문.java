package day03;

public class 연산자_제어문 {
	public static void main(String[] args) {
		
		//위의 코드를 보면 10.0과 10.0f의 관계 연산 결과는 true 이다. 그런데 바로 아래 0.1과 0.1f의 관계 연산 결과는 false이다.
//		결과가 다른 이유는 10.0f는 오차없이 저장할 수 있는 값이라 double로 형변환해도 그대로 10.0이 되지만, 0.1f는 저장할 때 2진수로 변환하는 과정에서 오차가 발생한다.
//		더 자세히 설명하면 1. 0.1과 0.1f 연산 시 default double형이 더 크므로 0.1f float 타입이 -> double 타입으로 변하게 된다.
		// 2. float타입의 값을 double타입으로 형변환하면, 부호와 지수가 달라지지 않고 가수의 빈자리를 0으로 채운다.
		//		0 01111011 10011001100110011001101
		//		0 0001111111011 1001100110011001100110100000000000000000000000000000
//		   3. 따라서 0.1f를 double타입으로 형변환했어도 값이 변하지 않았기 때문에 결과는 false이다.
//		   float와 double 타입의 값을 비교하려면 어떻게 해야할까?  double타입 값 -> float타입으로 형변환한 다음에 비교
		
		// 람다식
		// 식이기 때문에 끝에 ;를 안붙인다.
		//(매개변수 선언) -> { 문장 }
		
		// 반환타입 + 메서드이름이 날라가며, ()괄호속 인자에서, 괄호도 인자가 1개면 생략가능하다. 그러나 type이 추론가능하면 생략 가능하다.
		// (a, b) -> a > b ? a : b
		//  a     -> a * a // OK.
		// int a  -> a * a // 에러.
		
		// 괄호 { }안의 문장이 하나인 경우 괄호 { }를 생략할 수 있다. 이 때 문장의 끝에 ;을 붙이지 않아야 한다. 그러나 괄호 { } 안의 문장이 return문일 경우 생략할 수 없다.
//	    (String number, int i) -> {
//	        System.out.println(number + ":" + i);
//	      }
		// 괄호 { } 생략
//	    (String number, int i) -> System.out.println(number + ":" + i) // OK.
		
//		 int roll() {
//		      return (int)(Math.random() * 2);
//		    }
//		 // 괄호 { } 생략시 ->  에러. return문이기 때문에 생략 불가.
//		 () -> return (int)(Math.random() * 2) 
		
		
		
		// java12부터 switch문 확장
		
		//case에 복수의 값을 설정할 수 있게 되었다. Java 12의 멀티 레이블 규칙 (',' 콤마로 구분)이나 화살표(arrow) 식은 13버전 에서도 사용 가능하다.  
		//지시자(->)를 사용하여 break(13부터는 yield)를 생략할 수 있게 되었다.
//	    String time;
//	    switch(weekday) {
//	      case MONDAY, FRIDAY -> time = "10:00 - 18:00";
//	      case TUESDAY, THURSDAY -> time = "10:00 - 14:00";
//	      default -> time = "휴일";
//	    }
		//블록을 사용하여 여러가지 처리를 작성할 수 있게 되었다.
		//Switch를 식으로도 사용할 수 있다. 지시자 문법을 사용하지 않는 경우나 지시자 문법에 블록을 사용한 경우 break로 값을 반환한다.

		// java13부터 변경
		//Java 13에서 수정사항이 생겼는데, break로 값을 반환하는 문법이 yield로 변경되었다. break를 이용한 값 반환 방법이 없어지고 대안으로 yield를 사용할 수 있게 된 것이다.

		
		// 제어문 == flow를 바꾸어놓는.. 건너뛰는 선택문 / 반복되는 반복문
		// 선택문 == 조건문 -> if or switch
		// 반복문 =

		// 블럭: 괄호 { }를 이용해서 여러 문장을 하나의 단위로 묶을 수 있는데, 이것을 블럭(block)이라고 한다. 블럭은 {로 시작해서 }로 끝나고 } 뒤에 ;를 붙이지 않는다.
		// if문 블럭: 언뜻 보기에는 else블럭이 바깥쪽 if문에 속한 것처럼 보이지만 괄호가 생략되었을 때 else블럭은 가까운 if문에 속한 것으로 간주된다. 따라서 아래와 같이 되어 else블럭은 어떠한 경우에도 수행이 되지 않는다.
		
		// 선택문2. switch문
		//switch문은 단 하나의 조건식으로 많은 경우의 수를 처리할 수 있고, 표현도 간결하여 알아보기 쉽다. 
		//따라서 처리할 경우의 수가 많은 경우에는 if문 보다 switch문으로 작성하는 것이 좋다. 다만 switch문은 제약조건이 있기 때문에, 경우의 수가 많아도 if문으로 작성해야하는 경우가 있다.
		//default문은 if문의 else블럭과 같은 역할을 한다. default문의 위치는 어디라도 상관없지만 보통 마지막에 두기 때문에 break문을 쓰지 않아도 된다.
//	    int level = 2;
//	      ...
//	    switch(level) {
//	        case 3 :
//	            grantDelete(); // 삭제 권한을 준다.
//	        case 2 :
//	            grantWrite();  // 쓰기 권한을 준다.
//	        case 1 :
//	            grantRead();   // 읽기 권한을 준다.
//	    }
		//회원제 웹 사이트에서 쓸 법한 간단한 코드의 일부이다. 등급에 따라서 권한을 부여하는 코드인데, 
		// 제일 높은 등급인 3을 가진 사용자는 모두 수행되어 읽기, 쓰기, 삭제 권한까지 모두 가지게 되고, 제일 낮은 등급인 1을 가진 사용자는 읽기 권한만 가지게 된다.
		//break문이 없기 때문에 해당 case문 아래에 존재하는 case문이 시행되고 더 이상 문장이 없으면 switch문을 빠져나온다. case문은 한 줄에 하나씩 쓰던, 한 줄에 붙여서 쓰던 상관없다.

		//switch문의 제약조건: 	switch문의 조건식은 결과값이 반드시 정수이어야 하며, 이 값과 일치하는 case문으로 이동하기 때문에 case문의 값 역시 정수이어야 한다. 그리고 중복되지 않아야 한다.
		//게다가 case문의 값은 반드시 상수이어야 한다. 변수나 실수, 문자열은 사용할 수 없다. -> "문자열 상수 가능"
		
		//반복문: 며, for문, while문, do-while문이 있다.
		//for:     for(int i = 1, j = 0; ...; ...) { ... } -> 일반적으로 변수 하나로 for문을 제어하지만 둘 이상의 변수가 필요할 때는 콤마 ,를 구분자로 변수를 초기화하면 된다. 단, 두 변수의 타입은 같아야 한다.
		//        for(...; ...; i++, j--) { ... }
//	    for(...; ...; i++) { ... }      // 1씩 증가
//	    for(...; ...; i--) { ... }      // 1씩 감소
//	    for(...; ...; i += 2) { ... }   // 2씩 증가
//	    for(...; ...; i *= 3) { ... }   // 3배씩 증가
		
		//향상된 for문(enhanced for statement) : JDK 1.5부터 [배열과 컬렉션]에 저장된 요소에 접근할 때 기존보다 편리한 방법으로 처리할 수 있도록 for문의 새로운 문법이 추가되었다.
		// - 타입은 배열 또는 컬렉션의 요소의 타입이어야 한다. 배열 또는 컬렉션에 저장된 값이 매 반복마다 하나씩 순서대로 읽혀서 변수에 저장된다.
		//for(타입 변수명 : 배열 또는 컬렉션) {
        //     //반복할 문장
        //}
//		int[] arr = {10, 20, 30, 40, 50};
//		for(int tmp: arr) {
//			System.out.println(tmp);
//		}
		//위에 작성된 향상된 for문은 일반적인 for문과 동일하지만, 배열이나 컬렉션에 저장된 요소들을 읽어오는 용도로만 사용할 수 있다는 제약이 있다.
		
		// do-while문은 while문의 변형으로 기본적인 구조는 while문과 같으나 조건식과 블럭의 순서를 바꿔놓은 것이다. 그래서 while문과는 반대로 블럭을 먼저 수행한 후에 조건식을 평가한다.
		
		//continue문은 반복문 내에서만 사용될 수 있으며, 반복이 진행되는 도중에 continue문을 만나면 반복문의 끝으로 이동하여 다음 반복으로 넘어간다. for문은 증감식으로, while문과 do-while문은 조건식으로 이동한다.
		// - break문과 달리 반복문 전체를 벗어나지 않는다. 전체 반복 중에 특정조건을 만족하는 경우를 제외하고자 할 때 유용하다.

		//이름 붙은 반복문
		//break문은 근접한 단 하나의 반복문만 벗어날 수 있기 때문에, 여러 개의 반복문이 중첩된 경우에는 완전히 벗어날 수 없다.
		//-> 이 때 중첩 반복문 앞에 이름을 붙이고 break문과 continue문에 이름을 지정해 주면 하나 이상의 반복문을 벗어나거나 건너뛸 수 있다.
		
		//실습
		
		
		// JUnit5
		// JDK 1.4에서 추가된 assertXXX를 사용하여 Test를 진행할 수 있는데 결과를 Test클래스로 남겨서 개발자에게 테스트 방법 및 클래스의 History를 넘겨줄 수도 있다.
		// JUnit 5는 Platform, Jupiter, Vintage 세 가지 서브 프로젝트의 여러 모듈로 구성되어 있다.
		//Architecture
//		1. Platform
//			Test를 실행하고 관리하는 플랫폼 모듈.
//			JVM에서 테스트를 진행하기 위한 TestEngine API를 제공.
//		2. Jupiter
//			JUnit 5의 TestEngine API의 구현체.
//			JUnit 5에서 테스트 및 확장하기 위한 프로그래밍 모델과 확장 모델의 조합.
//		3. Vintage
//			JUnit 3과 JUnit 4의 TestEngine API 구현체.
//			하위 버전 기반의 테스트를 실행시키기 위해 해당 TestEngine을 제공.

		//사용된 어노테이션(Annotations): Jupiter에서 테스트와 확장된 기능을 위해 다양한 어노테이션을 제공하는데 그 중에 사용된 어노테이션은 다음과 같다.
//		@Test : 테스트 메소드임을 알린다.
//		@DisplayName("이름") : 해당 테스트 클래스 혹은 메소드에 대한 이름을 정할 수 있다.
//		@BeforeAll : 클래스의 모든 테스트 메서드가 실행하기 전 가장 먼저 실행된다.
//		@AfterAll : 클래스의 모든 테스트 메서드가 실행된 후 가장 마지막에 실행된다.
//		@BeforeEach : 클래스의 각각의 테스트 메서드가 실행되기 전 실행된다.
//		@AfterAll : 클래스의 각각의 테스트 메서드가 실행된 후 실행된다
		
//		Assertions: Assertion을 통해 자신의 로직이 정확한지 테스트 해볼 수 있다.
//		 - Jupiter에서는 기존 버전에 존재했던 Assertion 메소드를 포함하고, 람다와 함께 사용하기 적합한 추가 메소드를 제공한다.
//
//		Assertions	설 명
//		@assertEquals(expected, actual)	기대한 값(expected)이 실제 값(actual)과 일치하는지 확인한다.
//		@assertArrayEquals(expected, actual)	기대한 배열의 값(expected)이 실제 배열의 값(actual)과 일치하는지 확인한다.
//		@assertIterableEquals(expected, actual)	기대한 iterable 자료구조의 값(expected)이 실제 iterable 자료구조의 값(actual)과 일치하는지 확인한다.
//		@assertNotNull(actual)	null인지 아닌지 확인한다.
//		@assertTrue(boolean)	참인지 아닌지 확인한다.
//		@assertAll(executable...)	여러 개의 케이스를 하나로 묶어 테스트 하는데 사용한다.
//		@assertThrows(expectedType, executable)	기대한 예외가 나오는지 확인한

		
//		char grade = ' '; //char는 반드시 작은따옴표 1개로..







		












		
		
	}
}
