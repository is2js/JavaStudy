package day04;

public class 클래스 {
	
	// 클래스 구성: 필드 -> (생성자) -> (메소드)
	
	// 클래스 : 설계도 -> 객체 생성이 쉬워지고, 바로바로 만들어서 사용.
	// 클래스는 [객체지향이론의 관점]에서 내린 정의이고, [프로그래밍적 관점]에서는 또 다르다. 
	// **프로그래밍언어에서 [[[**데이터 처리를 위한 데이터 저장형태**]]]의 발전과정은 다음과 같다.**
//	변수 : 하나의 데이터를 저장할 수 있는 공간
//	배열 : [**같은 종류의 여러 데이터**]를 하나의 집합으로 저장할 수 있는 공간
//	구조체 : [서로 관련된 여러 데이터를 종류에 관계없이] 하나의 집합으로 저장할 수 있는 공간
//	클래스 : [**종류상관없이 서관 데이터**]와 [**서관 함수**]의 결합(구조체 + 함수)
	
	// -> 구조체(structure)가 등장하여 자료형의 종류에 상관없이 서로 관계가 깊은 변수들을 하나로 묶어서 다룰 수 있도록 했다.
	// -> 서로 관련된 변수들을 정의하고 이들에 대한 작업을 수행하는 함수들을 함께 정의한 것이 클래스이다. 
	// -> C언어에서는 문자열을 문자의 배열로 다루지만, Java에서는 String이라는 클래스로 문자열을 다룬다. 문자열을 클래스로 정의한 이유는 문자열과 문자열을 다루는데 필요한 함수들을 함께 묶기 위해서이다.
//    public final class String implements java.io.Serializable, Comparable { // -> 클래스는
//        private char[] value;   // 문자열을 저장하기 위한 공간 // -> 서관 데이터 저장을 위한 변수 
//        public String replace(char oldChar, char newChar) { // -> 서관 함수까지!
	
	
	// 사용자정의 타입(user-defined type): 프로그래머가 서로 관련된 변수들을 묶어서 하나의 타입으로 새로 추가하는 것을 사용자정의 타입(user-defined type)이라고 한다
	// ->  클래스가 곧 사용자 정의 타입 -> 기본형의 개수는 8개로 정해져 있지만 참조형의 개수는 정해져 있지 않은 이유가 바로 프로그래머가 새로운 타입(클래스를 이용하여)을 추가할 수 있기 때문이다.
	
	// 객체지향적 관점 ->  속성은 멤버변수, 기능은 메서드라는 용어로 자주 사용된다.
	
	
	// 클래스 메소드(static메소드)와 인스턴스 메소드
	// 1. 인스턴스 메소드 ->  인스턴스 변수와 관련된 작업을 하는, 즉 메소드의 작업을 수행하는데 인스턴스 변수를 필요로 하는 메서드이다.
	// 2. 클래스 메소드 -> 인스턴스와 관계없는 (인스턴스 변수나 인스턴스 메소드를 사용하지 않는) 메소드를 클래스 메소드(static 메소드)로 정의한다.
	// -> **객체를 만들어서 사용하는, 인스턴스 변수를 사용하지 않는다고 해서 반드시 클래스 메소드로 정의해야하는 것은 아니지만 특별한 이유가 없는 한 그렇게 하는 것이 일반적이다.**
	
	// **static 변수or메소드 고려**
//	1. 클래스 설계 시, [멤버변수 중 모든 인스턴스에서 공통으로 사용]하는 것에 static 추가
//	2. 클래스 변수(static 변수)는 [인스턴스를 생성하지 않아도 사용 가능]
//	3. 클래스 메소드(static 메소드)는 [인스턴스 변수를 사용할 수 없음]
//	4. 메소드 내에서 [인스턴스 변수를 사용하지 않는다면, static을 붙이는 것을 고려]
	
	//cf) 오버로딩(overloading): 	한 클래스 내에 같은 이름의 메소드를 여러 개 정의
	// - 메소드 이름이 같아야 한다.
	// - 매개변수의 개수 또는 타입이 달라야 한다.
//	void println()
//	void println(boolean x)
//	void println(char x)
//	void println(int x)
	
	//제어자(modifier) :  public, private, static 같은 것들은 무엇인가? -> 제어자(modifier)
//	 - 접근 제어자(택1) : public, protected, default, private  ( public vs  밖에서 호출안하고, 내부처리용 변수와 함수? private)
//	 - 그 외 : static, final, abstract, native, transient, synchronized, volatile, strictfp
	
	// 1. static - 클래스의, 공통적인 -> 객체생성없이, 같은 클래스 내부라면 바로 호출가능한, 클래스변수=멤버변수=static변수, class로드시 바로 메모리에 로드  / 객체가 생성될지라도 같은 값을 공유하는 변수 
	// -> static이 붙은 멤버변수와 메서드, 그리고 **초기화 블럭**은 인스턴스가 아닌 클래스에 관계된 것이기 때문에 인스턴스를 생성하지 않고도 사용할 수 있다.
	// -> static메서드 -> **static메서드 내에서는 인스턴스멤버들을 직접 사용할 수 없다.**
	// --> **인스턴스 멤버를 사용하지 않는 메서드는 static을 붙여서 static메서드로 선언하면 인스턴스를 생성하지 않고도 호출이 가능해 편리하고 속도도 빠르니 고려해보자.**
	// ---> **메서드가 클래스내부에..[ static안붙은 일반변수==인스턴스변수] 를 사용해야한다면, static메서드는 불가**
	
//    class StaticTest {
//        static int width = 200;           // static 변수  -> 클래스내부라면 바로 & 외부라면 클래스. 으로 객체 생성 없이 사용됨.
//        static int height = 120;          // static 변수
//
//        static {                          // static 초기화 블럭 -> 주로 static변수를 초기화하는데 사용
//            // static변수의 복잡한 초기화 수행
//        }
//
//        static int max(int a, int b) {    // static 메서드 -> 클래스내부라면 바로 & 외부라면 클래스. 으로 객체 생성 없이 사용됨. -> 인스턴스변수를 사용하지 않을때는 static으로 편하게 메서드 사용
//            return a > b ? a : b;
//        }
//    }
	
	
	//2. final - 마지막의, 변경될 수 없는
	//변수 -> 사용되면 값을 변경할 수 없는 상수가 되며, 
	//메서드 -> 사용되면 오버라이딩을 할 수 없게 되고 
	//클래스 -> 사용되면 자신을 확장하는 자손클래스를 정의하지 못하게 된다 (상속불가?)
//    final class FinalTest {             // class앞에 final? -> 상속불가  조상이 될 수 없는 클래스
//        final int MAX_SIZE = 10;        // 인변앞에 final? -> 값을 변경할 수 없는 멤버변수(상수)
//
//        final void getMaxSize() {       // 메서드앞에 final? -> 오버라이딩할 수 없는 메서드(변경불가)
//            final int LV = MAX_SIZE;    // 지역변수앞에 final? -> 값을 변경할 수 없는 지역변수(상수)
//            return MAX_SIZE;
//        }
//    }
	
	//2-1. 생성자를 이용한 final멤버변수의 초기화도 가능하다. (어디서 final은.. 생성과 동시에 초기화해줘야한다고 햇는데.. 안하면 에러나는데... 블록 + 초기화가  밑에 들어서면 에러가 사라진다!)
	//   final이 붙은 변수는 상수이므로 일반적으로 선언과 동시에 초기화를 동시에 하지만, **[인스턴스변수]**의 경우 생성자에서 초기화 되도록 할 수 있다.
	// -> 실습
	
	// 추상 클래스는 아직 완성되지 않은 메서드는 존재하는 ‘미완성 설계도’이므로 -> '인스턴스를 생성할 수 없다.'
	// 추상 메서드 -> 구현부만 없다( 반환+함수이름 있음. 람다가 반환+함수이름 없음)




	// 3. 접근 제어자: [ 멤버(멤버변수, 메서드, 생성자) 또는 클래스] 를 [ 외부에서 접근하지 못하도록 제한 ] 하는 것 -> public proteced default private
	// 1) 생략되었다면 default : [같은 패키지] 모두 접근 가능.
	// 2) public : 제한없이 어디서나 -> 모듈로서 따로 떼어써도 되는 것들
	// 3) protected : 같은패키지  +  다른패키지라도 상속하는 자손클래스까지 허용 
	// 4) private : [같은 클래스내에서만] -> 현재 class에서만 쓸 예정!! -> 다른 클래스에서 호출안됨.
	
	// 4. 대상별 접근제어자****
	// 1) class -> (default)아니면 public (내가 모듈로 쓸 클래스 생성시)
	// 2) 함수(method) -> 한 곳(class)에서만 쓸거면 private, 다른데서도 쓸거면 default(패키지) or public(모든 곳)  
	// 3) 멤버변수 ->  한 곳(class)에서만 쓸거면 private, 다른데서도 쓸거면 default(패키지) or public(모든 곳)
	// 4) 지역변수 -> 없음.
	
	
	// 5. **제어자 조합**
	// 1) class -> public or default인데,  + @@ abstract or final 가능@@ 
	// 2,3) 함수, 멤버변수(method) -> **메서드와 변수는 접근제어는 다 가능**( 여기서만(class) private / 패키지default/모든곳public ) + @@ 메서드와 변수 static(객체생성없이), final(상수) 가능 @@  + 메서드는  abstract까지    
	// 4) 지역변수 -> final빼고 접근제어자 및 제어자 불가능.
	
	// 6. 제어자조합 주의사항
//	1. 메서드에 static과 abstract를 함께 사용할 수 없다. -> static메서드는 몸통{구현부}이 있는 메서드에만 사용해서.. 객체없이 여기서만 편하게 사용
//	2. 클래스에 abstract와 final을 동시에 사용할 수 없다. -> 클래스에 사용되는 final은 클래스를 확장(상속)할 수 없다는 의미이고 vs abstract는 상속을 통해서 완성되어야 한다는 의미이므로 서로 모순되기 때문이다.
//	3. abstract메서드의 접근 제어자가 private일 수 없다 -> abstract메서드는 자손클래스에서 구현해주어야 하는데 접근 제어자가 private이면, 자손클래스에서 접근할 수 없기 때문 -> 구현도 못한다.
//	4. 메서드에 private과 final을 같이 사용할 필요는 없다. ->	접근 제어자가 private인 메서드는 오버라이딩될 수 없기 떄문이다. 둘 중 하나만 사용해도 의미가 충분하다.
	// -> 외부에서 접근안하고,, 여기class에서만 사용한다? -> 변경될일없다? -> 마치 상수나 마찬가지다.
	
	// 7.  객체는  [클래스에 정의된 내용대로 메모리에 생성된 것]을 말함. 속성(서관 데이터들) + 기능(서관 메서드)을 가진다.
	// - 결국 인스턴스는 객체와 같은 의미이지만, 객체는 모든 인스턴스를 대표하는 포괄적인 의미를 가지고 있으며, 인스턴스는 어떤 클래스로부터 만들어진 것인지를 강조하는 보다 구체적인 의미를 가지고 있다.
	// - 객체가 가지고 있는 속성과 기능을 그 객체의 멤버(구성원, member)라 한다.
	
	// 객체 생성 : new 키워드를 사용하여 생성된 객체(heap)의 주소를  ---주소---> 클래스명 변수 의 참조변수(stack)에 저장하는데 JVM의 heap 영역에 객체가 생성되고 stack 영역에서는 객체의 주소값만 가지고 있게 된다.
	// -> 실습
	// ****멤버변수를 초기화 안해주면, 객체마다 int형이면 0 등의 기본값이 미리 들어가있다.
	
	
	// 8. 메서드 정의 방법
	// 매개변수도 메서드 내에 선언된 것으로 간주되므로 지역변수(local variable)이다.
	// 매개변수의 개수는 거의 제한이 없지만, 입력해야할 값의 개수가 많은 경우에는 배열이나 참조변수를 사용하면 된다. 값을 입력받을 필요가 없다면 괄호() 안을 비워두면 된다.
	// 인자(argument)와 매개변수(parameter) : 메서드를 호출할 때 괄호 안에 지정해준 값들을 ‘인자(argument)’ 또는 ‘인수’라고 하는데, 인자의 개수와 순서는 호출된 메서드에 선언된 매개변수와 일치해야 한다. 또한 인자는 메서드가 호출되면서 매개변수에 대입되므로, 인자의 타입은 매개변수의 타입과 일치하거나 자동 형변환이 가능한 것이어야 한다.
	
	// 9. 생성자.
	// * 생성자의 조건
	// - 생성자의 이름은 클래스의 이름과 같아야 한다.
	// - 생성자는 리턴 값이 없다
	// * 생성자도 오버로딩이 가능하므로 하나의 클래스에 여러 개의 생성자가 존재할 수 있다. -> 인자없는 생성자를 정의해서 기본 초기값 넣어주는 것 있었음.
	
//    클래스이름 (타입 변수명, 타입 변수명, ... ) {
//        // 인스턴스 생성 시 수행될 코드,
//        // 주로 인스턴스 변수의 초기화 코드를 적는다.
//    }
	
//    Target tg = new Target();
//	위 코드가 수행되는 과정을 단계별로 나누어보면 다음과 같다.
//	1. 연산자 new에 의해서 메모리(heap)에 Target클래스의 인스턴스가 생성된다.
//	2. 생성자 Target()이 호출되어 수행된다.
//	3. 연산자 new의 결과로, 생성된 Target인스턴스의 주소가 반환되어 참조변수 tg에 저장된다.
	//-> 인스턴스를 생성하기 위해서 사용해왔던 ‘클래스이름()’이 바로 생성자이다! 인스턴스를 생성할 때는 반드시 클래스 내에 정의된 생성자 중의 하나를 선택하여 지정해주어야 한다.
	
	// 9-1. 기본 생성자(default constructor)
	// - 모든 클래스에는 반드시 하나 이상의 생성자가 정의되어 있어야 한다. 그러나 
	// - 지금까지 클래스에 생성자를 정의하지 않고도 인스턴스를 생성할 수 있었던 이유는 컴파일러가 제공하는 ‘기본 생성자(default constructor)’ 덕분이다.
	// - 컴파일을 할 때, 소스파일(*.java)의 클래스에 생성자가 하나도 정의되어 있지 않은 경우 컴파일러는 자동적으로 아래와 같은 기본 생성자를 추가하여 컴파일 한다.
	//   Target() { } // 파라미터가 없고, 초기화 부분도 비어있는 기본생성자는 컴파일러가 제공해서 안적어도 된다.
	// - 참고로 클래스의 ‘접근 제어자(Access Modifier)’가 public인 경우에는 기본 생성자로 ‘public 클래스이름() { }’이 추가된다.
	// -> 특별히 인스턴스 초기화 작업이 요구되지 않는다면 생성자를 정의하지 않고 컴파일러가 제공하는 기본 생성자를 사용하는 것도 좋다.
	
	// 실습 -> 생성자가 아예 없을 때만, 기본ㅅ성자가 제공되고, 만약, 매개변수를 받는 생성자를 생성했다면, 기본생성자는 제공되지 않는다. 따로 정의해야한다.
	
	// 9-2. 매개변수가 있는 생성자: 생성자도 메서드처럼 매개변수를 선언하여 호출 시 값을 넘겨받아 인스턴스의 초기화 작업에 사용할 수 있다.
	//- User인스턴스를 생성할 때, User()를 사용한다면 인스턴스를 생성한 후에 인스턴스변수들을 따로 초기화해주어야 하지만, 매개변수가 있는 생성자 User(String n, String l)을 사용한다면 인스턴스를 생성하는 동시에 원하는 값으로 초기화를 할 수 있게 된다.
//    class User {
//        String name;
//        String language;
//			// 1) 기본생성자 정의해주기 -> 멤버변수 초기화는 따로 해야한다.
//        User() { }
	 		// 2) 매개변수 받는 정의해주기
//        User(String n, String l) {
//            name = c;
//            language = l;
//        }
//    }


	// 10. this 키워드 이해하기
	// 생성자 간에도 서로 호출이 가능하다. 단, 다음 두 조건을 만족시켜야 한다.
	// 1. [생성자 내부에서 타]생성자의 이름으로 [클래스이름 대신 this]를 사용한다.
	// 2. 한 생성자에서 다른 생성자를 호출할 때는 [반드시 첫 줄에서만 호출]이 가능하다.
	
//    User(String name) {
//        language = "java";
//        User(name, "java");   // 에러1. 두 번째 줄에서 생성자 호출 -> 첫줄에 타생성자 호출해야함.
//    }                         // 에러2. 타생성자 호출시 this()로 호출해야함. -> this(name, "java");로 해야함
	
	// 11. this. vs this()
	// 1) this : [해당 클래스내]에서 생성될 객체의 참조변수명를 this로 가정하여 -> this.인스턴스변수 or this.인스턴스메소드를 호출하여 코드를 짤 수 있다.
	// -> (객체단위로서 )‘this’를 사용할 수 있는 것은 인스턴스멤버뿐이다. static메서드에서는 인스턴스멤버들을 사용할 수 없는 것처럼, ‘this’ 역시 사용할 수 없다.
	// -> 생성자를 포함한 모든 인스턴스메서드에는 자신이 관련된 인스턴스를 가리키는 참조변수 ‘this’가 지역변수로 숨겨진 채로 존재한다.
	
//	this: 인스턴스 자신을 가리키는 참조변수. 인스턴스의 주소가 저장되어 있다. 	모든 인스턴스 메서드에 지역변수로 숨겨진 채 존재한다.
//	this( ), this(매개변수): 생성자. 같은 클래스의 다른 생성자를 호출할 때 사용한다.
//	this vs  this( )는 비슷하게 생겼지만 완전히 다른 것이다. this는 ‘참조변수’이고, this( )는 ‘생성자’이다.

	// ****python처럼) 아래는 위에서 정의한 매개변수 있는 생성자인데 만약 [생성자의 매개변수로 선언된 변수의 이름이 [인스턴스 변수]와 같을 때에도 this를 사용]한다.
//	Car(String color, String gearType, int door) {
//		  this.color = color;
//		  this.gearType = gearType;
//		  this.door = door;
//		}
	// 이유는 color = color; 라고 하면 두 값이 구분되지 않으므로, this.color = color;라고 작성하면 this 키워드로 인해 인스턴스 변수의 color 라고 알 수 있기 때문이다.
	// 	당연한 말이지만, static메소드(클래스 메소드)에서는 인스턴스 멤버들을 사용할 수 없는것처럼(main메서드 -> static붙은 변수만 사용 가능, 쓰려면 객체 생성해서 써야함.) this 역시 사용할 수 없다.
	
	
	//블럭 초기화랑 생성자 초기화가 같이 있으면 어느 것이 출력되는가?	A. 생성자가 나온다.
	
	// 12. 초기화 블록: 초기화 블록 내에서는 조건문, 반복문 등을 사용해 명시적 초기화에선 불가능한 초기화를 수행할 수 있다.
	// 클래스 초기화 블럭 - 클래스 변수 초기화에 쓰인다. static { }
//		클래스 변수 초기화 : 기본값 → 명시적 초기화 → 클래스 초기화 블럭
	//인스턴스 초기화 블럭 - 인스턴스 변수 초기화에 쓰인다. { }
//	인스턴스 변수 초기화 : 기본값 → 명시적 초기화 → 인스턴스 초기화 블럭 → 생성자
//    class Class {
//        String instanceVar;
//        static String classVar; // static붙으면 편하게 쓰는 클래스변수
//
//        // 클래스 초기화 블럭
//        static {
//            classVar = "Class Variable";
//        }
//
//        // 인스턴스 초기화 블럭
//        {
//            instanceVar = "instance Variable";
//        }
//    }
	

	

}
